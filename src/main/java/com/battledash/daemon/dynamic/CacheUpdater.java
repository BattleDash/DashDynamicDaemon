package com.battledash.daemon.dynamic;

import com.battledash.daemon.dynamic.utils.HTTPClient;
import com.google.gson.Gson;
import lombok.Getter;
import com.battledash.daemon.dynamic.models.APIResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.bind.DatatypeConverter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

public class CacheUpdater {
    private static final Logger log = LoggerFactory.getLogger(CacheUpdater.class);

    @Getter
    public final File archives = new File("./cache/archives/");
    @Getter
    public final List<String> lockedGametypes = new CopyOnWriteArrayList<>();

    public CacheUpdater() {
        archives.mkdirs();
        new Timer().scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                try {
                    CacheUpdater.this.update();
                } catch (InterruptedException e) {
                    log.error("The request to NCP failed while attempting to update archive caches.", e);
                } catch (IOException e) {
                    log.error("An I/O error occurred deleting or reading from an archive while attempting to update archive caches.", e);
                } catch (NoSuchAlgorithmException e) {
                    log.error("The SHA-256 algorithm cannot be found. HOW.", e);
                }
            }
        }, 0, 1000 * 60);
    }

    /**
     * Downloads/Replaces a cached gamemode archive
     * with one generated by Network Control.
     *
     * @param gameType The TypeID of the gamemode.
     * @return The archive {@link File}
     */
    private File downloadArchive(String gameType) {
        lockedGametypes.add(gameType);
        log.info("Downloading archive for {}", gameType);
        File file = Paths.get(archives.getAbsolutePath(), gameType + ".tar.gz").toFile();
        try (FileOutputStream out = new FileOutputStream(file)) {
            HTTPClient.client.sendAsync(HttpRequest.newBuilder()
                    .uri(URI.create("https://" + Env.NCP_HOST + ":" + Env.NCP_PORT + "/daemon/dynamic/servers/" + gameType + "/serverArchive"))
                    .setHeader("Authorization", Env.NCP_SECRET)
                    .GET()
                    .build(), HttpResponse.BodyHandlers.ofInputStream()).thenApply(HttpResponse::body)
                    .join()
                    .transferTo(out);
        } catch (IOException e) {
            log.error("Failed to download Server Archive for {}", gameType, e);
        }
        log.info("Done downloading archive for {}", gameType);
        lockedGametypes.remove(gameType);
        return file;
    }

    /**
     * Pulls hashes of all type archives from Network Control,
     * compares against cached archives, and creates/updates/deletes
     * archives as needed.
     *
     * @throws InterruptedException if the request to Network Control fails.
     * @throws IOException if an I/O error occurs in deleting or reading from archives.
     * @throws NoSuchAlgorithmException if the SHA-256 algorithm cannot be found, which should be impossible.
     */
    public void update() throws InterruptedException, IOException, NoSuchAlgorithmException  {
        HttpResponse<String> send = HTTPClient.client.send(HttpRequest.newBuilder()
                .uri(URI.create("https://" + Env.NCP_HOST + ":" + Env.NCP_PORT + "/daemon/dynamic/servers/cachedHashes"))
                .setHeader("Authorization", Env.NCP_SECRET)
                .GET()
                .build(), HttpResponse.BodyHandlers.ofString());
        APIResponse<LinkedHashMap<String, Object>> apiResponse = new APIResponse<>(new Gson().fromJson(send.body(), LinkedHashMap.class));
        if (apiResponse.isSuccessful()) {
            Map<String, Object> data = apiResponse.getData();
            log.debug(data.entrySet().stream().map(d -> d.getKey() + ": " + d.getValue()).collect(Collectors.joining("\n")));
            List<String> collect = Arrays.stream(Objects.requireNonNull(archives.list())).filter(s -> !data.containsKey(s.split(".tar.gz")[0])).collect(Collectors.toList());
            if (collect.size() >= 1) {
                for (String s : collect) {
                    log.info("{} is no longer in the gamemode hashes, removing all caches of it", s);
                    Files.deleteIfExists(Paths.get("./cache/archives/" + s));
                }
            }
            for (Map.Entry<String, Object> modeHashEntry : data.entrySet()) {
                File file = Paths.get(archives.getAbsolutePath(), modeHashEntry.getKey() + ".tar.gz").toFile();
                if (file.exists()) {
                    MessageDigest md = MessageDigest.getInstance("SHA-256");
                    md.update(Files.readAllBytes(file.toPath()));
                    if (!DatatypeConverter.printHexBinary(md.digest()).toLowerCase().equals(modeHashEntry.getValue())) {
                        log.info("Updating Archive since hashes don't match ({}, {})", DatatypeConverter.printHexBinary(md.digest()).toLowerCase(),
                                modeHashEntry.getValue());
                        downloadArchive(modeHashEntry.getKey());
                    }
                } else {
                    downloadArchive(modeHashEntry.getKey());
                }
            }
        }
    }

}
